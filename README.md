
# üêç Fundamentals of Programming

This course introduces the software engineering mindset, focusing strictly on **Python**. It moves beyond basic syntax to cover Modular Programming, Layered Architecture, Design Patterns (GRASP), and Algorithmic Complexity.

### üìÖ Weekly Syllabus

The curriculum aligns theory with practical implementation. Laboratories typically require assignment submissions **one week** after they are assigned.

| Week | üë®‚Äçüè´ Lecture Content | üìù Seminar | üíª Laboratory |
|:---:|:---|:---|:---|
| **1** | **Intro:** Basics, Interpreter, Roles, Iteration modeling | Intro to Python & Simple problems | Simple Python program |
| **2** | **Procedural:** Compound types (list/dict), Functions, TDD | Procedural Programming | Feature-driven development (I) |
| **3** | **Modular:** Packages, Separation of concerns, Logical layers | Modular Programming (I) | Feature-driven development (II) |
| **4** | **User Types:** Encapsulation, Data hiding, Abstract Data Types | Modular Programming (II) | Feature-driven development (III) |
| **5** | **Design Guidelines:** Layered Arch, GRASP, Principles (SOLID) | Object Based Programming | ‚ùó **LABORATORY TEST** |
| **6** | **OOP:** Classes, Objects, Inheritance, Exceptions, UML | User Defined Types | Layered Architecture (I) |
| **7** | **Program Design:** Top-down vs Bottom-up strategies | Program Design I (Layered Arch) | Layered Architecture (II) |
| **8** | **Testing:** Unit/Integration testing, TDD, Refactoring | Program Design II (Layered Arch) | Layered Architecture (III) |
| **9** | **Recursion:** Direct and indirect recursion | Program Design III (Inspection) | Text Files |
| **10** | **Complexity:** Asymptotic analysis (Big-O), Structural complexity | Recursion & Algo Complexity | Program Testing |
| **11** | **Search & Sort:** Binary search, MergeSort, QuickSort, etc. | Searching & Sorting | Algorithm Complexity |
| **12** | **Problem Solving I:** Greedy and Backtracking methods | Program Design Recap | Problem Solving Methods |
| **13** | **Problem Solving II:** Divide & Conquer and Dynamic Programming | Greedy, Divide & Conquer | üèÅ **PRACTICAL EXAM SIMULATION** |
| **14** | **Revision:** Exam guide and topic review | Backtracking, Dynamic Programming | Assignment delivery |

---

### üìö Key Topics Breakdown

<details>
<summary><strong>Click to expand detailed topic list</strong></summary>

#### Part I: Software Engineering Basics
*   **Procedural:** Functions, Scope, Parameter passing.
*   **Modular:** Dependency, Coupling, Cohesion, Single Responsibility Principle.
*   **TDD:** Test-Driven Development loops.

#### Part II: Architecture & Design
*   **Layered Architecture:** UI Layer $\rightarrow$ Service Layer $\rightarrow$ Repository Layer $\rightarrow$ Domain.
*   **GRASP Patterns:** Information Expert, Creator, Controller, Low Coupling, High Cohesion.
*   **OOP:** Classes, Inheritance, Polymorphism, Operator Overloading.

#### Part III: Algorithms & Complexity
*   **Complexity:** Big-O notation ($\mathcal{O}(n)$, $\mathcal{O}(n \log n)$, etc.), Best/Worst/Average case.
*   **Sorting:** BubbleSort, SelectionSort, InsertionSort, QuickSort, MergeSort.
*   **Strategies:**
    *   **Greedy:** Making the locally optimal choice.
    *   **Backtracking:** Generating all solutions (e.g., N-Queens).
    *   **Divide & Conquer:** Breaking problems down (e.g., MergeSort).
    *   **Dynamic Programming:** Optimizing recursion with memoization.

</details>

---

### üõ†Ô∏è Resources & Tools

*   **PyCharm / VS Code** - Recommended IDEs for Python development.
*   **PyUnit / pytest** - Frameworks for Unit Testing.
*   **PEP 8** - Style Guide for Python Code.

---

> *"First, solve the problem. Then, write the code."* ‚Äî John Johnson
